# Lesson: Advanced Interaction Technologies & Applications

### First and Last Name: Evangelia Despotidou
### University Registration Number: dpsd19030
### GitHub Personal Profile: [Evedes01](https://github.com/Evedes01)
### Advanced Interaction Tecnologies & Applications Github Personal Repository: [Advanced Interaction Technologies Personal Repository](https://github.com/Evedes01/Advanced-Interaction-Tecnologies-Applications-Individual-Assignment)

# Introduction

# Summary


# 1st Deliverable
>##  1. Video Capture: 
Για το πρώτο βήμα, ξεκίνησα κατεβάζοντας στο Processing το library για το Video και έπειτα ακολούθησα τις οδηγίες του [συδέσμου](https://processing.org/tutorials/video/#live-video) και του παραδείγματος 16-1 του βιβλίου Learning Processing για να γράψω τον κώδικα. Αφού άλλαξα τις διαστάασεις του παραθύρου

![](Report_materials/step1_1.PNG)

έτρεξα το πρόγραμμα.
<br>'Οπως φαίνεται παρακάτω, το πρόγραμμα τρέχει σωστά και εμφανίζεται το βίντεο που καταγράφει η κάμερα.

![](Report_materials/step1_2.PNG)

Και η ένδειξη στον compiler:

![](Report_materials/step1_dec.PNG)

<br>

>##  2. Recorded video: 
Για αυτό το βήμα, συμβουλευόμενη τα παραδείγματα 16-4 και 16-5 του βιβλίου και χρησιμοποιώντας το library που είχα κατεβάσει στο προηγούμενο βήμα, υλοποίησα την προβολή του βίντεο. Αρχικά, έγραψα τον κώδικα σ΄ύμφωνα με τα παραδείγματα και και δηημιούργησα έναν φάκελο "data" (στον ίδιο φάκελο με το πρόγραμμα), όπου μέσα τοποθέτησα το βίντεο. 

![](Report_materials/step2_data.PNG)

Συνειδητοποιώντας τον όγκο του αρχείου, επεξεργάστηκα το βίντεο με σκοπό να το μικρύνω (με compression και επιταχύνοντας το αρχικό animation, για να ελαχιστοποιηθεί το μήκος του).

Όσων αφορά τον κώδικα, πάλι προσάρμωσα τις διαστάσεις του παραθύρου, ώστε να ταιριάζουν με αυτές του βίντεο.

![](Report_materials/step2_1copy.png)

Έπειτα, το έτρεξα και δοκιμασα την επιβράδυνση και την επιτάχυνση του βίντεο σερνοντας το ποντίκι οριζοντίως πάνω του...

![](Report_materials/step2_2.PNG) ![](Report_materials/step2_3.PNG)

και λειτούργησε ομαλά, το βίντεο έπαιζε σε λούπα και στις διαφορετικές ταχύτητες.

<br>

>##  3. QR Code:  
Για την δημιουργία του QR code επισκέφτηκα [αυτή](https://www.qrcode-monkey.com/?utm_source=google_c&utm_medium=cpc&utm_campaign=&utm_content=&utm_term=qrcode%20monkey_e&gclid=CjwKCAjw8JKbBhBYEiwAs3sxN6yxfBJHuRFeC35FTpOlhm42mXNSqnNOPvVUIutf8s3RqK6aTZ6WOBoC8PsQAvD_BwE) την ιστοσελίδα και αφού το έφτιαξα, το κατέβασα και το τοποθέτησα στον φάκελο data.

<br><br>Για το πρόγραμμα, αρχικά, κατέβασα την βιβλιοθήκη για το QR Code από το σχετικό [link](https://shiffman.net/p5/qrcode-processing/) (ανοίγοντας τα Developer tools, καθώς αντιμετώπιζε κάποιο πρόβλημα το link στην ιστοσελίδα), αλλά επειδή δεν κατάφερα να την αποθηκεύσω σωστα, τελικά, την κατέβασα μέσω του Processing, όπου καταχωρήθηκε αμέσως.
<br>Στη συνέχεια, αντέγραψα τον κώδικα της ιστοσελίδας στο Processing και προσέθεσα και κάποια στοιχεία του κώδικα από το παράδειγμα 15-1 του βιβλίου, όπως το "PImage img;" για να μπορώ να εισάγω και να χρησιμοποιήσω την εικόνα του QR:

![](Report_materials/step3_1copy.png)

Προσάρμωσα τις διαστάσεις του παραθύρου (πορτοκαλί) και της εικόνας (γαλάζιο):

![](Report_materials/step3_1col.png)

Για να μπορεί να ανοίξει το decoded κείμενο/link του GitHub προφίλ μου σε νέο παράθυρο στον browser:
<br>
<br>Χρησιμοποίησα ένα switch case όπως στον κώδικα του βήματος 4, και προσέθεσα και προσάρμωσα τη γραμμή κώδικα που βρήκα [εδώ](https://processing.org/examples/embeddedlinks.html), αντικαθιστώντας το απλό link με την εντολή "decoder.getDecodedString()" που περιέχει το decoded link του QR σε string.

![](Report_materials/step3_1link.png)

Τέλος, έτρεξα το πρόγραμμα:
<br><br>Εμφανίστηκε η εικόνα του QR (και από τον compiler φάνηκε ότι διάβασε το QR code)

![](Report_materials/step3_2.PNG) ![](Report_materials/step3_dec.PNG)

και πατώντας το πλήκτρο "i" (όπως είναι καταχωρημένο στο switch case), το πρόγραμμα επιτυχώς άνοιξε το GitHub profile στον browser.

![](Report_materials/step3_3.PNG)

<br>

>##  4. QR Code - Camera Read: 

Για αυτό το βήμα χρησιμοποίησα το QR code και το library από το προηγούμενο βήμα, και, όπως προηγουμένως, εισήγαγα στο data file την εικόνα του QR code.

<br>Όσων αφορά τον κώδικα, άνοιξα και επεξεργάστηκα το παράδειγμα _QRCodeExample_. Ο κώδικας παρέμεινε σταθερός, ενώ οι βασικές αλλαγές που έκανα ήταν στις εντολές του switch case:
<br><br>
Πρώτα στην εισαγωγή του προσωπικού μου QR code...

![](Report_materials/step4_1.PNG)

και έπειτα, προσθέτοντας ένα νέο case, το πλήκτρο "o", με το οποίο ενεργοποιείται η εντολή να ανοίξει το αποκωδικοποιημένο link στον browser.

![](Report_materials/step4_11.png)
<br>(χρησιμοποίησα την ίδια γραμμή κώδικα με το βήμα 3, από αυτή τη [σελίδα](https://processing.org/examples/embeddedlinks.html))

<br>Όταν έτρεξα το πρόγραμμα, το παράθυρο με το βίντεο από την κάμερα εμφανίστηκε κανονικά, ενώ η μόνη μικρή δυσκολία ήταν να αναγνωρίσει σωστά η κάμερα το QR code. Στο status mmessage φαίνεται όταν το αναγνωρίζει επιτυχώς (κάθε φορά τραβώντας screenshot με το "space-bar"), 

![](Report_materials/step4_3.PNG) ![](Report_materials/step4_4.PNG) ![](Report_materials/step4_5.PNG)

ενώ στον compiler οι προσπάθειες αναγνώρισης.

![](Report_materials/step4_dec.PNG)

Παρ'όλα αυτά, το πρόγραμμα λειτούργησε και πατώντας το "o", το προφίλ άνοιξε επιτυχώς σε καινούριο tab στον browser.

 ![](Report_materials/step4_6.PNG)
 
 <br>

>##  5. Augmented Reality:  

Για το 5ο βήμα ξεκίνησα κατεβάζοντας τον φάκελο zip (“nyar4psg.zip”) που περιέχει την βιβλιοθήκη NyARToolkit από τον [σύνδεσμο](https://github.com/nyatla/NyARToolkit-for-Processing/releases) στο GitHub, τον οποίο τοποθέτησα στον φάκελο _Libraries_ του Processing. 

Στη συνέχεια, από το πρόγραμμα, άνοιξα για να επεξεργαστώ το παράδειγμα _simpleLite_:

![](Report_materials/step5_0.PNG)

και δημιούργησα έναν φάκελο data, όπου τοποθέτησα όλα τα περιεχόμενα του φακέλου data που περιέχονταν στο NyARToolkit και προσέθεσα και την εικόνα (“planets”), την οποία θα προβάλει το πρόγραμμα όταν αναγνωρίζει τον marker.

Προχωρώντας στον κώδικα:
<br><br>Πρώτα, προσέθεσα στην αρχή, μαζί με τις βιβλιοθήκες, την εντολή "PImage img;" για να μπορώ να εισάγω και να επεξεργαστώ την εικόνα.

![](Report_materials/step5_10.png)

Πειραματίστηκα με τις διαστάσεις του παραθύρου, μέχρι να βρω τις καταλληλότερες τιμές, και προσάρμοσα τα marker paths, ώστε να καλούνται σωστά τα αρχεία (.dat και patt) που βρίσκονται στον φάκελο data.

![](Report_materials/step5_11.png)

Σε αυτή τη φάση προσέθεσα την εικόνα μέσα στην void _draw_ και έτρεξα για πρώτη φορά το πρόγραμμα, όπου φάνηκε η φωτογραφία με το ήδη υπάρχον _box_. 

![](Report_materials/step5_1.PNG)

Συνέχισα αφαιρώντας το κουτί και προσαρμόζοντας το μέγεθος ("image(…,…, x, y)"), την περιστροφή ("rotationZ") και την τοποθέτηση ("translate") της εικόνας σε σχέση με τον marker, εισάγοντας μεταβλητές (για την περιστροφή) από [αυτή]( https://processing.org/reference/rotateZ_.html) τη σελίδα.

![](Report_materials/step5_2.PNG)

Ξανά έτρεξα μερικές φορές το πρόγραμμα με κάθε αλλαγή που έκανα και μετά από προσαρμογές στις παραπάνω μεταβλητές κατέληξα σε αυτό το αποτέλεσμα. 

![](Report_materials/step5_3.PNG)

# 2nd Deliverable
>##  1. Background Removal: 

Αρχικά, άνοιξα το παράδειγμα 16-12. Όρισα μια μεταβλητή Movie για να μπορέσω να χρησιμοποιήσω ένα βίντεο για την αντικατάσταση του background.

![](Report_materials/code1_1.png)

Κατέβασα ένα βίντεο της επιλογής μου και το έκοψα, ώστε να μην ξεπερναι τα 10" και το έκανα drag and drop στο πρόγραμμα, βάζοντας το αυτόματα στν φάκελο data του προγράμματος.

Στη συνέχεια επέστρεψα στο πρόγραμμα άλλαξα το size του παραθύρου για να είναι το ίδιο μέγεθος με το βίντεο, καθώς αργότερα αυτό θα βοηθούσε με την καλύτερη αντιστοίχιση και αντικατάσταση των pixel.

![](Report_materials/code1_2.PNG)

Δημιούργησα στην setup ένα καινούριο Movie object και κάλσα το όνομα του βίντεο και το έβαλα να παίξει σε λούπα.

![](Report_materials/code1_3.PNG)

Αντικατέστησα το captureEvent με movieEvent, καθώς θέλουμε να διαβάζεται το βίντεο από το πρόγραμμα.

![](Report_materials/code1_4.PNG)

Τέλος, μέσα στην else, έσβησα το πράσινο χρώμα και έβαλα να αντικαθιστόνται τα "ακίνητα" pixels με τον πίνακα των του βίντεο.

![](Report_materials/code1_5.PNG)

Έτρεξα το πρόγραμμα και δέν φάνηκε αρκετά το βίντεο στο φόντο, οπότε αύξησα το threshold (πόσο διαφέρουν τα pixels πριν και μετά) για να καλυφθούν περισσότερα κενά.

Το τελικό απότέλεσμα είναι αυτο:

![](Report_materials/step1clip.gif)

>##  2. Motion Detection:

Για αυτό το ερώτημα βρήκα την άσκηση 16-7 έτοιμη στα παραδείγματα του Processing και πειραματίστηκα με την εμφάνιση του σημείου, μετατρέποντάς το σε ορθογώνιο, καταλήγοντας σε αυτό:

![](Report_materials/code2_snip.png)

Εδώ είναι το αποτέλεσμα:

![](Report_materials/step2clip.gif)

>##  3. Background Substraction:

Σε αυτό το step έπρεπε το βίντεο να αντιατασταθεί με το feed από την κάμερα, οι βιβλιοθήκες περέχονταν ήδη. Ξεκίνησα αφαιρόντας τις μεταβλητές και τα functions που ήταν σχετικά με την προβολή του βίντεο (street.mov). 

Στη συνέχεια, προσέθεσα την μεταβλητή Capture και την αναγκαία μεταβλητή για την έναρξη του βίντεο της κάμερας μέσα στην setup. 

![](Report_materials/st3code1.png) ![](Report_materials/st3code2.png)

Τέλος, μετέτρεψα την captureMovie σε captureEvent, ώστε να παίζει αυτό που βλέπει η κάμερα.

![](Report_materials/st3code3.png)

Πλέον το πρόγραμμα ακολουθεί την κίνηση που πιάνει η κάμερα και δημιουργεί ένα περίγραμμα:

![](Report_materials/step3clip.gif)

-Πλεονεκτήματα και μειονεκτήματα της έτοιμης βιβλιοθήκης έναντι του κώδικα από το πρώτο ερώτημα:

πλεονεκτήματα: Κάνει τη δουλειά του προγραμματιστή πιο γρήγορη, καθώς διαθέτει έτοιμα εργαλεία και συναρτήσεις που μπορούν να χρησιμοποιηθούν άμεσα. Επείσης, πολλές φορές οι έτοιμες βιβλιοθήκες προσφέρουν μεγαλύτερη ακρίβεια και καλύτερα αποτελέσματα, αφού διαθέτουν καλύτερη και πιο λεπτομερή οργάνωση.

μειονεκτήματα: Δεν διαθέτει όση ευελιξία διασαθέτει η δδημιουργία κώδικα/προγράμματος from scratch. Πολλές από τις μεταβλητές και τα functions είναι προκαθορισμένα, και δεν είναι εύκολο να τροποποιηθούν.


>##  4. Object Tracking:

Για αυτό το βήμα χρησιμοποίησα τον κώδικα από την άσκηση 16-5, και προσάρμωσα τα χρώματα στο φιδάκι ώστε να κάνει μια ομαλή μετάβαση μεταξύ δύο μη βασικών χρωμάτων. Αυτή την αλλαγή την έκανα στην καρτέλα (κλάση) Snake, αφού εκεί ορίζεται το σχήμα ("φιδάκι") και οι παράμετροι για τη δημιουργία αυτών των γραφικών/graphics.

![](Report_materials/st4code1.png)

Εδώ είναι το τελικό αποτέλεσμα:

![](Report_materials/step4clip.gif)

-Πλεονεκτήματα και μειονεκτήματα αυτής της τεχνικής ελέγχου σε σχέση με το παραδοσιακό ποντίκι:

πλεονεκτήματα: Βασικό πλεονέκτημα υτής της τεχνικής είναι ότι δίνει πολύ μεγαλύτερη ευελιξία στο χρήστη να κινήσει το φιδάκι μέσα στο "χώρο". Ακόμα πιο βασικό είναι ότι κάνει την αλληλεπίδραση με το πρόγραμμα πιο ζωντανή, ενεργή και ενδιαφέρουσα για τον χρήστη, από το απλά να κινεί το ποντίκι στην οθόνη του, όπου μπορεί να έχει και μεγαλύτερους περιορισμούς κίνησης.

μειονεκτήματα: Η χρήση αυτής της τεχνικής ελέγχου εξαρτάται σε αρκετά μεγάλο βαθμό από την ποιότητα της εικόνας της κάμερας και τη δυνατότητα του πρτογράμματος και του υπολογιστή να επεξεργαστεί τα δεδομένα από αυτήν. Επίσης, δεν μποιρεί να επιτύχει την ίδια ακρίβεια με το ποντίκι, καθώς το tracking ενός συγκεκριμένου χρώματος δεν έιναι τόσο επιτυχές όταν το φόντο δεν είναι "καθαρό", ή όταν υπάρχουν άλλα παρόμοια χρώματα με αυτό που του έχουμε δώσει να κάνει tracking. 
Με λίγα λόγια, αυτή η τεχνική ελέγχου παράγει περισσότερα σφάλματα, όπως φάνηκε και στην παραπάνω απεικόνιση.

# 3rd Deliverable 


# Bonus 


# Conclusions


# Sources
